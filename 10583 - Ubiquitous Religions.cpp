/* ****************************************************************************************
    集合合併的方法為：
        1.找出兩個集合內最小(也可以最大)的值(一開始皆為index)。  -> while-loop來實現 (*註)
        2.比較兩者誰大誰小，將較大者的值用較小者的值取代，此過程會改變array內的值，
          使之不為index值。
        3.最後只要算出有幾個值仍為原值，就可以得知有幾個集合。
**************************************************************************************** */

/* ---------------------------------------------------------------------------------------
    (*註)用while-loop的原因：

        一開始時，各集合皆只有一個元素，或許可以用if來判斷；
        但是當好幾層配對關係之後，可能會有以下情況

        EX.
            (4,8) -> (2,4) -> (1,2)  //  (7,9) -> (5,7) -> (3,5)

        此時array內的值各自為
            table[1] = 1    table[3] = 3
            table[2] = 1    table[5] = 3
            table[4] = 2    table[7] = 5
            table[8] = 4    table[9] = 7

        若此時有一配對(8,9)，我們必須找到這兩個集合各自的最小值(1和3)才能進行集合合併，
        這個時候我們就需要用一個while-loop，不斷地看array裡的值跟array的index是否相等，
        當兩者相等時，就代表找到集合中的最小值(因為非最小值者，array裡的值都被改掉了)
--------------------------------------------------------------------------------------- */
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#define MAX 50001

using namespace std;

int table[MAX];

int main()
{
    int n, m, a, b, ans, cases, a_min, b_min;

    scanf("%d %d", &n, &m);

    cases = 1;
    while ( !(n == 0 && m == 0) ) {
        if (n == 0)
            break;

        /* 一開始array內的值跟index相同，如果都沒配對資訊，則會有n個不同的index，也就是n個集合 */
        for (int i = 1; i <= MAX; i++)
            table[i] = i;

        /* 讀接下來的M筆配對資訊 */
        for (int i = 1; i <= m; i++) {
            scanf("%d %d", &a, &b);

            while ( b != table[b])  /* 找該集合的最小值 */
                b = table[b];
            while ( a != table[a])  /* 找該集合的最小值 */
                a = table[a];

            if (a < b)        /* a較小，將b用a取代(b被合併到a) */
                table[b] = a;
            else if (a > b)   /* b較小，將a用b取代(a被合併到b) */
                table[a] = b;

            /* 若兩者相等，代表兩者早就已在同一個集合內，不需任何動作 */
        }

        ans = 0;
        for (int i = 1; i <= n; i++)
            /* array內的值跟index值相同，代表此數為該集合最小的值，此數是集合的頭，集合數+1 */
            if (i == table[i])
                ans++;

        printf("Case %d: %d\n", cases, ans);

        scanf("%d %d", &n, &m);
        cases++;
    }

    return 0;
}
